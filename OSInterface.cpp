#include "OSInterface.h"
#include <WinSock2.h>
#include <Windows.h>
#include <WS2tcpip.h>

const void* OSInterface::INVALID_TASK = INVALID_HANDLE_VALUE;

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: CreateSharedMem
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void* OSInterface::CreateSharedMem(const char* path, uint32_t maxLength)
{
  return CreateFileMappingA(INVALID_HANDLE_VALUE,
                            nullptr,
                            PAGE_READWRITE,
                            0,
                            maxLength,
                            path);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: GetSharedMem
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void* OSInterface::GetSharedMem(void* pSharedMem, uint32_t maxLength)
{
  return MapViewOfFile(pSharedMem, FILE_MAP_ALL_ACCESS, 0, 0, maxLength);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: CloseSharedMem
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void OSInterface::CloseSharedMem(void* pSharedMem)
{
  UnmapViewOfFile(pSharedMem);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SignalCreate
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void* OSInterface::SignalCreate(const char* name)
{
  void* sig = CreateEventA(nullptr, TRUE, FALSE, name);
  if (ERROR_ALREADY_EXISTS == GetLastError())
  {
    sig = GetSignal(name);
  }

  return sig;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: GetSignal
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void* OSInterface::GetSignal(const char* name)
{
  return OpenEventA(EVENT_ALL_ACCESS, FALSE, name);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SignalWait
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
StatusTypes::StatusEnum OSInterface::SignalWait(void* signal, uint32_t timeout)
{
  StatusTypes::StatusEnum status;

  unsigned long os_status = WaitForSingleObjectEx(signal, timeout, FALSE);
  switch (os_status)
  {
  case WAIT_OBJECT_0:
    status = StatusTypes::STATUS_OK;
    break;
  case WAIT_TIMEOUT:
    status = StatusTypes::STATUS_ERROR_TIMEOUT;
    break;
  default:
    status = StatusTypes::STATUS_ERROR;
  }

  SignalReset(signal);

  return status;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SignalNotify
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void OSInterface::SignalNotify(void* signal)
{
  SetEvent(signal); 
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SignalReset
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void OSInterface::SignalReset(void* signal)
{
  ResetEvent(signal);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SemCreate
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void* OSInterface::SemCreate(const char* name, int32_t iVal, int32_t mVal)
{
  void* sem = CreateSemaphoreA(nullptr, iVal, mVal, name);
  if (ERROR_ALREADY_EXISTS == GetLastError())
  {
    sem = GetSem(name);
  }

  return sem;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: GetSem
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
void* OSInterface::GetSem(const char* name)
{
  return OpenSemaphoreA(SEMAPHORE_ALL_ACCESS, FALSE, name);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SemTake
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
StatusTypes::StatusEnum OSInterface::SemTake(void* sem, uint32_t timeout)
{
  StatusTypes::StatusEnum status;

  unsigned long os_status = WaitForSingleObjectEx(sem, timeout, FALSE);
  switch (os_status)
  {
  case WAIT_OBJECT_0:
    status = StatusTypes::STATUS_OK;
    break;
  case WAIT_TIMEOUT:
    status = StatusTypes::STATUS_ERROR_TIMEOUT;
    break;
  default:
    status = StatusTypes::SEMMGR_TAKE_ERROR;
  }

  return status;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Function: SemGive
// Notes:    None
//
/////////////////////////////////////////////////////////////////////////////////////////
StatusTypes::StatusEnum OSInterface::SemGive(void* sem)
{
  if (0 == ReleaseSemaphore(sem, 1, nullptr))
  {
    return StatusTypes::SEMMGR_GIVE_ERROR;
  }

  return StatusTypes::STATUS_OK;
}